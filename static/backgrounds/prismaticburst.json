{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "prismaticburst",
  "type": "registry:block",
  "title": "PrismaticBurst",
  "description": "PrismaticBurst background component",
  "dependencies": [
    "svogl"
  ],
  "files": [
    {
      "path": "src/lib/backgrounds/PrismaticBurst/PrismaticBurst.svelte",
      "content": "<script lang=\"ts\">\n\timport { Canvas, Program, Mesh, Triangle, Texture } from 'svogl';\n\n\ttype Offset = { x?: number | string; y?: number | string };\n\ttype AnimationType = 'rotate' | 'rotate3d' | 'hover';\n\n\tinterface Props {\n\t\tintensity?: number;\n\t\tspeed?: number;\n\t\tanimationType?: AnimationType;\n\t\tcolors?: string[];\n\t\tdistort?: number;\n\t\tpaused?: boolean;\n\t\toffset?: Offset;\n\t\thoverDampness?: number;\n\t\trayCount?: number;\n\t\tmixBlendMode?: string;\n\t\tclass?: string;\n\t}\n\n\tlet {\n\t\tintensity = 2,\n\t\tspeed = 0.5,\n\t\tanimationType = 'rotate',\n\t\tcolors,\n\t\tdistort = 0,\n\t\tpaused = false,\n\t\toffset = { x: 0, y: 0 },\n\t\thoverDampness = 0,\n\t\trayCount,\n\t\tmixBlendMode = 'lighten',\n\t\tclass: className = ''\n\t}: Props = $props();\n\n\t// Utility functions\n\tconst hexToRgb01 = (hex: string): [number, number, number] => {\n\t\tlet h = hex.trim();\n\t\tif (h.startsWith('#')) h = h.slice(1);\n\t\tif (h.length === 3) {\n\t\t\tconst r = h[0],\n\t\t\t\tg = h[1],\n\t\t\t\tb = h[2];\n\t\t\th = r + r + g + g + b + b;\n\t\t}\n\t\tconst intVal = parseInt(h, 16);\n\t\tif (isNaN(intVal) || (h.length !== 6 && h.length !== 8)) return [1, 1, 1];\n\t\tconst r = ((intVal >> 16) & 255) / 255;\n\t\tconst g = ((intVal >> 8) & 255) / 255;\n\t\tconst b = (intVal & 255) / 255;\n\t\treturn [r, g, b];\n\t};\n\n\tconst toPx = (v: number | string | undefined): number => {\n\t\tif (v == null) return 0;\n\t\tif (typeof v === 'number') return v;\n\t\tconst s = String(v).trim();\n\t\tconst num = parseFloat(s.replace('px', ''));\n\t\treturn isNaN(num) ? 0 : num;\n\t};\n\n\t// Animation state\n\tlet mouseTarget = $state([0.5, 0.5]);\n\tlet mouseSmooth = $state([0.5, 0.5]);\n\tlet accumTime = $state(0);\n\tlet lastTime = $state(0);\n\n\t// Animation type mapping\n\tconst animTypeMap: Record<AnimationType, number> = {\n\t\trotate: 0,\n\t\trotate3d: 1,\n\t\thover: 2\n\t};\n\n\tconst vertex = `#version 300 es\n  in vec2 position;\n  in vec2 uv;\n  out vec2 vUv;\n  void main() {\n\t  vUv = uv;\n\t  gl_Position = vec4(position, 0.0, 1.0);\n  }\n  `;\n\n\tconst fragment = `#version 300 es\n  precision highp float;\n  precision highp int;\n  \n  out vec4 fragColor;\n  \n  uniform vec2  uResolution;\n  uniform float uTime;\n  \n  uniform float uIntensity;\n  uniform float uSpeed;\n  uniform int   uAnimType;\n  uniform vec2  uMouse;\n  uniform int   uColorCount;\n  uniform float uDistort;\n  uniform vec2  uOffset;\n  uniform sampler2D uGradient;\n  uniform float uNoiseAmount;\n  uniform int   uRayCount;\n  \n  in vec2 vUv;\n  \n  float hash21(vec2 p){\n\t  p = floor(p);\n\t  float f = 52.9829189 * fract(dot(p, vec2(0.065, 0.005)));\n\t  return fract(f);\n  }\n  \n  mat2 rot30(){ return mat2(0.8, -0.5, 0.5, 0.8); }\n  \n  float layeredNoise(vec2 fragPx){\n\t  vec2 p = mod(fragPx + vec2(uTime * 30.0, -uTime * 21.0), 1024.0);\n\t  vec2 q = rot30() * p;\n\t  float n = 0.0;\n\t  n += 0.40 * hash21(q);\n\t  n += 0.25 * hash21(q * 2.0 + 17.0);\n\t  n += 0.20 * hash21(q * 4.0 + 47.0);\n\t  n += 0.10 * hash21(q * 8.0 + 113.0);\n\t  n += 0.05 * hash21(q * 16.0 + 191.0);\n\t  return n;\n  }\n  \n  vec3 rayDir(vec2 frag, vec2 res, vec2 offset, float dist){\n\t  float focal = res.y * max(dist, 1e-3);\n\t  return normalize(vec3(2.0 * (frag - offset) - res, focal));\n  }\n  \n  float edgeFade(vec2 frag, vec2 res, vec2 offset){\n\t  vec2 toC = frag - 0.5 * res - offset;\n\t  float r = length(toC) / (0.5 * min(res.x, res.y));\n\t  float x = clamp(r, 0.0, 1.0);\n\t  float q = x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n\t  float s = q * 0.5;\n\t  s = pow(s, 1.5);\n\t  float tail = 1.0 - pow(1.0 - s, 2.0);\n\t  s = mix(s, tail, 0.2);\n\t  float dn = (layeredNoise(frag * 0.15) - 0.5) * 0.0015 * s;\n\t  return clamp(s + dn, 0.0, 1.0);\n  }\n  \n  mat3 rotX(float a){ float c = cos(a), s = sin(a); return mat3(1.0,0.0,0.0, 0.0,c,-s, 0.0,s,c); }\n  mat3 rotY(float a){ float c = cos(a), s = sin(a); return mat3(c,0.0,s, 0.0,1.0,0.0, -s,0.0,c); }\n  mat3 rotZ(float a){ float c = cos(a), s = sin(a); return mat3(c,-s,0.0, s,c,0.0, 0.0,0.0,1.0); }\n  \n  vec3 sampleGradient(float t){\n\t  t = clamp(t, 0.0, 1.0);\n\t  return texture(uGradient, vec2(t, 0.5)).rgb;\n  }\n  \n  vec2 rot2(vec2 v, float a){\n\t  float s = sin(a), c = cos(a);\n\t  return mat2(c, -s, s, c) * v;\n  }\n  \n  float bendAngle(vec3 q, float t){\n\t  float a = 0.8 * sin(q.x * 0.55 + t * 0.6)\n\t\t\t  + 0.7 * sin(q.y * 0.50 - t * 0.5)\n\t\t\t  + 0.6 * sin(q.z * 0.60 + t * 0.7);\n\t  return a;\n  }\n  \n  void main(){\n\t  vec2 frag = gl_FragCoord.xy;\n\t  float t = uTime * uSpeed;\n\t  float jitterAmp = 0.1 * clamp(uNoiseAmount, 0.0, 1.0);\n\t  vec3 dir = rayDir(frag, uResolution, uOffset, 1.0);\n\t  float marchT = 0.0;\n\t  vec3 col = vec3(0.0);\n\t  float n = layeredNoise(frag);\n\t  vec4 c = cos(t * 0.2 + vec4(0.0, 33.0, 11.0, 0.0));\n\t  mat2 M2 = mat2(c.x, c.y, c.z, c.w);\n\t  float amp = clamp(uDistort, 0.0, 50.0) * 0.15;\n  \n\t  mat3 rot3dMat = mat3(1.0);\n\t  if(uAnimType == 1){\n\t\tvec3 ang = vec3(t * 0.31, t * 0.21, t * 0.17);\n\t\trot3dMat = rotZ(ang.z) * rotY(ang.y) * rotX(ang.x);\n\t  }\n\t  mat3 hoverMat = mat3(1.0);\n\t  if(uAnimType == 2){\n\t\tvec2 m = uMouse * 2.0 - 1.0;\n\t\tvec3 ang = vec3(m.y * 0.6, m.x * 0.6, 0.0);\n\t\thoverMat = rotY(ang.y) * rotX(ang.x);\n\t  }\n  \n\t  for (int i = 0; i < 44; ++i) {\n\t\t  vec3 P = marchT * dir;\n\t\t  P.z -= 2.0;\n\t\t  float rad = length(P);\n\t\t  vec3 Pl = P * (10.0 / max(rad, 1e-6));\n  \n\t\t  if(uAnimType == 0){\n\t\t\t  Pl.xz *= M2;\n\t\t  } else if(uAnimType == 1){\n\t\tPl = rot3dMat * Pl;\n\t\t  } else {\n\t\tPl = hoverMat * Pl;\n\t\t  }\n  \n\t\t  float stepLen = min(rad - 0.3, n * jitterAmp) + 0.1;\n  \n\t\t  float grow = smoothstep(0.35, 3.0, marchT);\n\t\t  float a1 = amp * grow * bendAngle(Pl * 0.6, t);\n\t\t  float a2 = 0.5 * amp * grow * bendAngle(Pl.zyx * 0.5 + 3.1, t * 0.9);\n\t\t  vec3 Pb = Pl;\n\t\t  Pb.xz = rot2(Pb.xz, a1);\n\t\t  Pb.xy = rot2(Pb.xy, a2);\n  \n\t\t  float rayPattern = smoothstep(\n\t\t\t  0.5, 0.7,\n\t\t\t  sin(Pb.x + cos(Pb.y) * cos(Pb.z)) *\n\t\t\t  sin(Pb.z + sin(Pb.y) * cos(Pb.x + t))\n\t\t  );\n  \n\t\t  if (uRayCount > 0) {\n\t\t\t  float ang = atan(Pb.y, Pb.x);\n\t\t\t  float comb = 0.5 + 0.5 * cos(float(uRayCount) * ang);\n\t\t\t  comb = pow(comb, 3.0);\n\t\t\t  rayPattern *= smoothstep(0.15, 0.95, comb);\n\t\t  }\n  \n\t\t  vec3 spectralDefault = 1.0 + vec3(\n\t\t\t  cos(marchT * 3.0 + 0.0),\n\t\t\t  cos(marchT * 3.0 + 1.0),\n\t\t\t  cos(marchT * 3.0 + 2.0)\n\t\t  );\n  \n\t\t  float saw = fract(marchT * 0.25);\n\t\t  float tRay = saw * saw * (3.0 - 2.0 * saw);\n\t\t  vec3 userGradient = 2.0 * sampleGradient(tRay);\n\t\t  vec3 spectral = (uColorCount > 0) ? userGradient : spectralDefault;\n\t\t  vec3 base = (0.05 / (0.4 + stepLen))\n\t\t\t\t\t* smoothstep(5.0, 0.0, rad)\n\t\t\t\t\t* spectral;\n  \n\t\t  col += base * rayPattern;\n\t\t  marchT += stepLen;\n\t  }\n  \n\t  col *= edgeFade(frag, uResolution, uOffset);\n\t  col *= uIntensity;\n  \n\t  fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);\n  }`;\n\n\tconst gradientTextureValue = $derived.by(() => {\n\t\tif (!colors || colors.length === 0) {\n\t\t\treturn {\n\t\t\t\timage: new Uint8Array([255, 255, 255, 255]),\n\t\t\t\twidth: 1\n\t\t\t};\n\t\t}\n\t\tconst capped = colors.slice(0, 64);\n\t\tconst count = capped.length;\n\t\tconst data = new Uint8Array(count * 4);\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst [r, g, b] = hexToRgb01(capped[i]);\n\t\t\tdata[i * 4 + 0] = Math.round(r * 255);\n\t\t\tdata[i * 4 + 1] = Math.round(g * 255);\n\t\t\tdata[i * 4 + 2] = Math.round(b * 255);\n\t\t\tdata[i * 4 + 3] = 255;\n\t\t}\n\n\t\treturn {\n\t\t\timage: data,\n\t\t\twidth: count\n\t\t};\n\t});\n\t// Computed values\n\tconst offsetX = $derived(toPx(offset?.x));\n\tconst offsetY = $derived(toPx(offset?.y));\n\tconst colorCount = $derived(Array.isArray(colors) ? colors.length : 0);\n\tconst rayCountValue = $derived(Math.max(0, Math.floor(rayCount ?? 0)));\n</script>\n\n<Canvas\n\tclass={className}\n\tstyle={mixBlendMode && mixBlendMode !== 'none' ? `mix-blend-mode: ${mixBlendMode}` : ''}\n\tonMouseMove={({ e, rect, x, y }) => {\n\t\tmouseTarget = [Math.min(Math.max(x, 0), 1), Math.min(Math.max(y, 0), 1)];\n\t}}\n>\n\t{#snippet children(ogl)}\n\t\t<Texture\n\t\t\t{...gradientTextureValue}\n\t\t\twidth={1}\n\t\t\theight={1}\n\t\t\tgenerateMipmaps={false}\n\t\t\tflipY={false}\n\t\t\tminFilter={ogl.gl.LINEAR}\n\t\t\tmagFilter={ogl.gl.LINEAR}\n\t\t\twrapS={ogl.gl.CLAMP_TO_EDGE}\n\t\t\twrapT={ogl.gl.CLAMP_TO_EDGE}\n\t\t\t{...colors && colors.length > 0\n\t\t\t\t? {\n\t\t\t\t\t\tformat: ogl.gl.RGBA,\n\t\t\t\t\t\ttype: ogl.gl.UNSIGNED_BYTE,\n\t\t\t\t\t\tneedsUpdate: true\n\t\t\t\t\t}\n\t\t\t\t: {}}\n\t\t>\n\t\t\t{#snippet children(texture)}\n\t\t\t\t<Program\n\t\t\t\t\t{vertex}\n\t\t\t\t\t{fragment}\n\t\t\t\t\tuniforms={{\n\t\t\t\t\t\tuResolution: {\n\t\t\t\t\t\t\tvalue: [ogl.containerSize[0], ogl.containerSize[1]],\n\t\t\t\t\t\t\tnoUpdate: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\tuTime: { value: accumTime },\n\t\t\t\t\t\tuIntensity: { value: intensity },\n\t\t\t\t\t\tuSpeed: { value: speed },\n\t\t\t\t\t\tuAnimType: { value: animTypeMap[animationType] },\n\t\t\t\t\t\tuMouse: { value: mouseSmooth },\n\t\t\t\t\t\tuColorCount: { value: colorCount },\n\t\t\t\t\t\tuDistort: { value: distort },\n\t\t\t\t\t\tuOffset: { value: [offsetX, offsetY] },\n\t\t\t\t\t\tuGradient: { value: texture.texture },\n\t\t\t\t\t\tuNoiseAmount: { value: 0.8 },\n\t\t\t\t\t\tuRayCount: { value: rayCountValue }\n\t\t\t\t\t}}\n\t\t\t\t\tonResize={({ width, height }, program) => {\n\t\t\t\t\t\tprogram.program.uniforms.uResolution.value = [width, height];\n\t\t\t\t\t}}\n\t\t\t\t\tonUpdate={({ time }, program) => {\n\t\t\t\t\t\tconst currentTime = time * 0.001;\n\t\t\t\t\t\tconst dt = lastTime > 0 ? currentTime - lastTime : 0;\n\t\t\t\t\t\tlastTime = currentTime;\n\n\t\t\t\t\t\tif (!paused) {\n\t\t\t\t\t\t\taccumTime += dt;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Update time uniform\n\t\t\t\t\t\tprogram.program.uniforms.uTime.value = accumTime;\n\n\t\t\t\t\t\t// Smooth mouse interpolation for hover mode\n\t\t\t\t\t\tif (animationType === 'hover') {\n\t\t\t\t\t\t\tconst tau = 0.02 + Math.max(0, Math.min(1, hoverDampness)) * 0.5;\n\t\t\t\t\t\t\tconst alpha = 1 - Math.exp(-dt / tau);\n\t\t\t\t\t\t\tmouseSmooth[0] += (mouseTarget[0] - mouseSmooth[0]) * alpha;\n\t\t\t\t\t\t\tmouseSmooth[1] += (mouseTarget[1] - mouseSmooth[1]) * alpha;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Update mouse uniform\n\t\t\t\t\t\tprogram.program.uniforms.uMouse.value = mouseSmooth;\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<Triangle>\n\t\t\t\t\t\t<Mesh\n\t\t\t\t\t\t\tonUpdate={({ time }, mesh) => {\n\t\t\t\t\t\t\t\tmesh.ogl.renderer?.render({ scene: mesh.mesh });\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</Triangle>\n\t\t\t\t</Program>\n\t\t\t{/snippet}\n\t\t</Texture>\n\t{/snippet}\n</Canvas>\n",
      "type": "registry:component"
    }
  ]
}