{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "prism",
  "type": "registry:block",
  "title": "Prism",
  "description": "Prism background component",
  "dependencies": [
    "svogl"
  ],
  "files": [
    {
      "path": "src/lib/backgrounds/Prism/Prism.svelte",
      "content": "<script lang=\"ts\">\n\timport { Canvas, Program, Mesh, Triangle } from 'svogl';\n\n\tinterface Props {\n\t\theight?: number;\n\t\tbaseWidth?: number;\n\t\tanimationType?: 'rotate' | 'hover' | '3drotate';\n\t\tglow?: number;\n\t\toffset?: { x?: number; y?: number };\n\t\tnoise?: number;\n\t\ttransparent?: boolean;\n\t\tscale?: number;\n\t\thueShift?: number;\n\t\tcolorFrequency?: number;\n\t\thoverStrength?: number;\n\t\tinertia?: number;\n\t\tbloom?: number;\n\t\tsuspendWhenOffscreen?: boolean;\n\t\ttimeScale?: number;\n\t\tclass: string;\n\t}\n\n\tlet {\n\t\theight = 3.5,\n\t\tbaseWidth = 5.5,\n\t\tanimationType = 'rotate',\n\t\tglow = 1,\n\t\toffset = { x: 0, y: 0 },\n\t\tnoise = 0.5,\n\t\ttransparent = true,\n\t\tscale = 3.6,\n\t\thueShift = 0,\n\t\tcolorFrequency = 1,\n\t\thoverStrength = 2,\n\t\tinertia = 0.05,\n\t\tbloom = 1,\n\t\tsuspendWhenOffscreen = false,\n\t\ttimeScale = 0.5,\n\t\tclass: className = ''\n\t}: Props = $props();\n\n\t// Rotation matrix utilities\n\tconst rotBuf = new Float32Array(9);\n\tfunction setMat3FromEuler(\n\t\tyawY: number,\n\t\tpitchX: number,\n\t\trollZ: number,\n\t\tout: Float32Array\n\t): Float32Array {\n\t\tconst cy = Math.cos(yawY),\n\t\t\tsy = Math.sin(yawY);\n\t\tconst cx = Math.cos(pitchX),\n\t\t\tsx = Math.sin(pitchX);\n\t\tconst cz = Math.cos(rollZ),\n\t\t\tsz = Math.sin(rollZ);\n\n\t\tconst r00 = cy * cz + sy * sx * sz;\n\t\tconst r01 = -cy * sz + sy * sx * cz;\n\t\tconst r02 = sy * cx;\n\n\t\tconst r10 = cx * sz;\n\t\tconst r11 = cx * cz;\n\t\tconst r12 = -sx;\n\n\t\tconst r20 = -sy * cz + cy * sx * sz;\n\t\tconst r21 = sy * sz + cy * sx * cz;\n\t\tconst r22 = cy * cx;\n\n\t\tout[0] = r00;\n\t\tout[1] = r10;\n\t\tout[2] = r20;\n\t\tout[3] = r01;\n\t\tout[4] = r11;\n\t\tout[5] = r21;\n\t\tout[6] = r02;\n\t\tout[7] = r12;\n\t\tout[8] = r22;\n\t\treturn out;\n\t}\n\n\tfunction lerp(a: number, b: number, t: number): number {\n\t\treturn a + (b - a) * t;\n\t}\n\n\t// Animation state\n\tlet yaw = 0,\n\t\tpitch = 0,\n\t\troll = 0;\n\tlet targetYaw = 0,\n\t\ttargetPitch = 0;\n\tlet pointer = { x: 0, y: 0, inside: false };\n\n\t// Animation control\n\tlet canvasElement: HTMLCanvasElement | null = null;\n\tlet intersectionObserver: IntersectionObserver | null = null;\n\n\t// Lifecycle management\n\t$effect(() => {\n\t\tif (suspendWhenOffscreen && canvasElement) {\n\t\t\tintersectionObserver = new IntersectionObserver((entries) => {\n\t\t\t\tconst isVisible = entries.some((e) => e.isIntersecting);\n\t\t\t\t// svogl handles animation automatically, we just track visibility\n\t\t\t});\n\t\t\tintersectionObserver.observe(canvasElement);\n\t\t}\n\n\t\treturn () => {\n\t\t\tif (intersectionObserver) {\n\t\t\t\tintersectionObserver.disconnect();\n\t\t\t\tintersectionObserver = null;\n\t\t\t}\n\t\t};\n\t});\n\n\t// 3D rotation parameters (matching React version)\n\tconst wX = 0.3;\n\tconst wY = 0.2;\n\tconst wZ = 0.4;\n\tconst phX = 1.2;\n\tconst phZ = 0.8;\n\n\tconst vertex = `\nattribute vec2 position;\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\n\tconst fragment = `\nprecision highp float;\n\nuniform vec2  iResolution;\nuniform float iTime;\n\nuniform float uHeight;\nuniform float uBaseHalf;\nuniform mat3  uRot;\nuniform int   uUseBaseWobble;\nuniform float uGlow;\nuniform vec2  uOffsetPx;\nuniform float uNoise;\nuniform float uSaturation;\nuniform float uScale;\nuniform float uHueShift;\nuniform float uColorFreq;\nuniform float uBloom;\nuniform float uCenterShift;\nuniform float uInvBaseHalf;\nuniform float uInvHeight;\nuniform float uMinAxis;\nuniform float uPxScale;\nuniform float uTimeScale;\n\nvec4 tanh4(vec4 x){\n  vec4 e2x = exp(2.0*x);\n  return (e2x - 1.0) / (e2x + 1.0);\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat sdOctaAnisoInv(vec3 p){\n  vec3 q = vec3(abs(p.x) * uInvBaseHalf, abs(p.y) * uInvHeight, abs(p.z) * uInvBaseHalf);\n  float m = q.x + q.y + q.z - 1.0;\n  return m * uMinAxis * 0.5773502691896258;\n}\n\nfloat sdPyramidUpInv(vec3 p){\n  float oct = sdOctaAnisoInv(p);\n  float halfSpace = -p.y;\n  return max(oct, halfSpace);\n}\n\nmat3 hueRotation(float a){\n  float c = cos(a), s = sin(a);\n  mat3 W = mat3(\n    0.299, 0.587, 0.114,\n    0.299, 0.587, 0.114,\n    0.299, 0.587, 0.114\n  );\n  mat3 U = mat3(\n     0.701, -0.587, -0.114,\n    -0.299,  0.413, -0.114,\n    -0.300, -0.588,  0.886\n  );\n  mat3 V = mat3(\n     0.168, -0.331,  0.500,\n     0.328,  0.035, -0.500,\n    -0.497,  0.296,  0.201\n  );\n  return W + U * c + V * s;\n}\n\nvoid main(){\n  vec2 f = (gl_FragCoord.xy - 0.5 * iResolution.xy - uOffsetPx) * uPxScale;\n\n  float z = 5.0;\n  float d = 0.0;\n\n  vec3 p;\n  vec4 o = vec4(0.0);\n\n  float centerShift = uCenterShift;\n  float cf = uColorFreq;\n\n  mat2 wob = mat2(1.0);\n  if (uUseBaseWobble == 1) {\n    float t = iTime * uTimeScale;\n    float c0 = cos(t + 0.0);\n    float c1 = cos(t + 33.0);\n    float c2 = cos(t + 11.0);\n    wob = mat2(c0, c1, c2, c0);\n  }\n\n  const int STEPS = 100;\n  for (int i = 0; i < STEPS; i++) {\n    p = vec3(f, z);\n    p.xz = p.xz * wob;\n    p = uRot * p;\n    vec3 q = p;\n    q.y += centerShift;\n    d = 0.1 + 0.2 * abs(sdPyramidUpInv(q));\n    z -= d;\n    o += (sin((p.y + z) * cf + vec4(0.0, 1.0, 2.0, 3.0)) + 1.0) / d;\n  }\n\n  o = tanh4(o * o * (uGlow * uBloom) / 1e5);\n\n  vec3 col = o.rgb;\n  float n = rand(gl_FragCoord.xy + vec2(iTime));\n  col += (n - 0.5) * uNoise;\n  col = clamp(col, 0.0, 1.0);\n\n  float L = dot(col, vec3(0.2126, 0.7152, 0.0722));\n  col = clamp(mix(vec3(L), col, uSaturation), 0.0, 1.0);\n\n  if(abs(uHueShift) > 0.0001){\n    col = clamp(hueRotation(uHueShift) * col, 0.0, 1.0);\n  }\n\n  gl_FragColor = vec4(col, o.a);\n}\n`;\n</script>\n\n<Canvas\n\tclass={className}\n\tonMouseMove={({ e, rect, x, y }) => {\n\t\tif (animationType === 'hover') {\n\t\t\t// Use window coordinates like React version\n\t\t\tconst ww = Math.max(1, window.innerWidth);\n\t\t\tconst wh = Math.max(1, window.innerHeight);\n\t\t\tconst cx = ww * 0.5;\n\t\t\tconst cy = wh * 0.5;\n\t\t\tconst nx = (e.clientX - cx) / (ww * 0.5);\n\t\t\tconst ny = (e.clientY - cy) / (wh * 0.5);\n\t\t\tpointer.x = Math.max(-1, Math.min(1, nx));\n\t\t\tpointer.y = Math.max(-1, Math.min(1, ny));\n\t\t\tpointer.inside = true;\n\t\t}\n\t}}\n\tonMouseEnter={({ e, rect, x, y }) => {\n\t\tif (animationType === 'hover') {\n\t\t\tpointer.inside = true;\n\t\t}\n\t}}\n\tonMouseLeave={({ e, rect, x, y }) => {\n\t\tif (animationType === 'hover') {\n\t\t\tpointer.inside = false;\n\t\t}\n\t}}\n>\n\t{#snippet children(ogl)}\n\t\t<Program\n\t\t\t{vertex}\n\t\t\t{fragment}\n\t\t\tuniforms={{\n\t\t\t\tiResolution: { value: [ogl.containerSize[0], ogl.containerSize[1]], noUpdate: true },\n\t\t\t\tiTime: { value: 0 },\n\t\t\t\tuHeight: { value: Math.max(0.001, height) },\n\t\t\t\tuBaseHalf: { value: Math.max(0.001, baseWidth) * 0.5 },\n\t\t\t\tuUseBaseWobble: { value: animationType === 'rotate' ? 1 : 0 },\n\t\t\t\tuRot: { value: new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]) },\n\t\t\t\tuGlow: { value: Math.max(0.0, glow) },\n\t\t\t\tuOffsetPx: {\n\t\t\t\t\tvalue: [\n\t\t\t\t\t\t(offset?.x ?? 0) * window.devicePixelRatio,\n\t\t\t\t\t\t(offset?.y ?? 0) * window.devicePixelRatio\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tuNoise: { value: Math.max(0.0, noise) },\n\t\t\t\tuSaturation: { value: transparent ? 1.5 : 1 },\n\t\t\t\tuScale: { value: Math.max(0.001, scale) },\n\t\t\t\tuHueShift: { value: hueShift || 0 },\n\t\t\t\tuColorFreq: { value: Math.max(0.0, colorFrequency || 1) },\n\t\t\t\tuBloom: { value: Math.max(0.0, bloom || 1) },\n\t\t\t\tuCenterShift: { value: Math.max(0.001, height) * 0.25 },\n\t\t\t\tuInvBaseHalf: { value: 1 / (Math.max(0.001, baseWidth) * 0.5) },\n\t\t\t\tuInvHeight: { value: 1 / Math.max(0.001, height) },\n\t\t\t\tuMinAxis: { value: Math.min(Math.max(0.001, baseWidth) * 0.5, Math.max(0.001, height)) },\n\t\t\t\tuPxScale: { value: 1 / ((ogl.containerSize[1] || 1) * 0.1 * Math.max(0.001, scale)) },\n\t\t\t\tuTimeScale: { value: Math.max(0, timeScale || 1) }\n\t\t\t}}\n\t\t\tonResize={({ width, height: h }, program) => {\n\t\t\t\tprogram.program.uniforms.iResolution.value = [width, h];\n\t\t\t\tprogram.program.uniforms.uPxScale.value = 1 / ((h || 1) * 0.1 * Math.max(0.001, scale));\n\t\t\t}}\n\t\t\tonUpdate={({ time }, program) => {\n\t\t\t\tconst currentTime = time * 0.001;\n\t\t\t\tprogram.program.uniforms.iTime.value = currentTime;\n\n\t\t\t\t// Update derived uniforms\n\t\t\t\tconst H = Math.max(0.001, height);\n\t\t\t\tconst BW = Math.max(0.001, baseWidth);\n\t\t\t\tconst BASE_HALF = BW * 0.5;\n\t\t\t\tprogram.program.uniforms.uCenterShift.value = H * 0.25;\n\t\t\t\tprogram.program.uniforms.uInvBaseHalf.value = 1 / BASE_HALF;\n\t\t\t\tprogram.program.uniforms.uInvHeight.value = 1 / H;\n\t\t\t\tprogram.program.uniforms.uMinAxis.value = Math.min(BASE_HALF, H);\n\n\t\t\t\t// Animation control logic - determine if we should continue animating\n\t\t\t\tlet continueAnimation = true;\n\n\t\t\t\t// Handle different animation types\n\t\t\t\tif (animationType === 'hover') {\n\t\t\t\t\t// Mouse-based rotation\n\t\t\t\t\tconst HOVSTR = Math.max(0, hoverStrength || 1);\n\t\t\t\t\tconst maxPitch = 0.6 * HOVSTR;\n\t\t\t\t\tconst maxYaw = 0.6 * HOVSTR;\n\t\t\t\t\ttargetYaw = (pointer.inside ? -pointer.x : 0) * maxYaw;\n\t\t\t\t\ttargetPitch = (pointer.inside ? pointer.y : 0) * maxPitch;\n\n\t\t\t\t\tconst INERT = Math.max(0, Math.min(1, inertia || 0.12));\n\t\t\t\t\tyaw = lerp(yaw, targetYaw, INERT);\n\t\t\t\t\tpitch = lerp(pitch, targetPitch, INERT);\n\t\t\t\t\troll = lerp(roll, 0, 0.1);\n\n\t\t\t\t\tprogram.program.uniforms.uRot.value = setMat3FromEuler(yaw, pitch, roll, rotBuf);\n\t\t\t\t\tprogram.program.uniforms.uUseBaseWobble.value = 0;\n\n\t\t\t\t\t// Check if animation has settled\n\t\t\t\t\tconst settled =\n\t\t\t\t\t\tMath.abs(yaw - targetYaw) < 1e-4 &&\n\t\t\t\t\t\tMath.abs(pitch - targetPitch) < 1e-4 &&\n\t\t\t\t\t\tMath.abs(roll) < 1e-4;\n\t\t\t\t\tif (settled) continueAnimation = false;\n\t\t\t\t} else if (animationType === '3drotate') {\n\t\t\t\t\t// Automatic 3D rotation\n\t\t\t\t\tconst TS = Math.max(0, timeScale || 1);\n\t\t\t\t\tconst tScaled = currentTime * TS;\n\t\t\t\t\tyaw = tScaled * wY;\n\t\t\t\t\tpitch = Math.sin(tScaled * wX + phX) * 0.6;\n\t\t\t\t\troll = Math.sin(tScaled * wZ + phZ) * 0.5;\n\n\t\t\t\t\tprogram.program.uniforms.uRot.value = setMat3FromEuler(yaw, pitch, roll, rotBuf);\n\t\t\t\t\tprogram.program.uniforms.uUseBaseWobble.value = 0;\n\n\t\t\t\t\tif (TS < 1e-6) continueAnimation = false;\n\t\t\t\t} else {\n\t\t\t\t\t// Default rotation with base wobble\n\t\t\t\t\trotBuf[0] = 1;\n\t\t\t\t\trotBuf[1] = 0;\n\t\t\t\t\trotBuf[2] = 0;\n\t\t\t\t\trotBuf[3] = 0;\n\t\t\t\t\trotBuf[4] = 1;\n\t\t\t\t\trotBuf[5] = 0;\n\t\t\t\t\trotBuf[6] = 0;\n\t\t\t\t\trotBuf[7] = 0;\n\t\t\t\t\trotBuf[8] = 1;\n\t\t\t\t\tprogram.program.uniforms.uRot.value = rotBuf;\n\t\t\t\t\tprogram.program.uniforms.uUseBaseWobble.value = 1;\n\n\t\t\t\t\tif (Math.max(0, timeScale || 1) < 1e-6) continueAnimation = false;\n\t\t\t\t}\n\n\t\t\t\t// Animation continues automatically with svogl\n\t\t\t}}\n\t\t>\n\t\t\t<Triangle>\n\t\t\t\t<Mesh\n\t\t\t\t\tonUpdate={({ time }, mesh) => {\n\t\t\t\t\t\tmesh.ogl.renderer?.render({ scene: mesh.mesh });\n\t\t\t\t\t}}\n\t\t\t\t/>\n\t\t\t</Triangle>\n\t\t</Program>\n\t{/snippet}\n</Canvas>\n",
      "type": "registry:component"
    }
  ]
}