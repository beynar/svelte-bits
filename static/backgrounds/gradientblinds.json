{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "gradientblinds",
  "type": "registry:block",
  "title": "GradientBlinds",
  "description": "GradientBlinds background component",
  "dependencies": [
    "svogl"
  ],
  "files": [
    {
      "path": "src/lib/backgrounds/GradientBlinds/GradientBlinds.svelte",
      "content": "<script lang=\"ts\">\n\timport { Canvas, OglContext, Program, Mesh, Triangle } from 'svogl';\n\n\tinterface GradientBlindsProps {\n\t\tclassName?: string;\n\t\tdpr?: number;\n\t\tpaused?: boolean;\n\t\tgradientColors?: string[];\n\t\tangle?: number;\n\t\tnoise?: number;\n\t\tblindCount?: number;\n\t\tblindMinWidth?: number;\n\t\tmouseDampening?: number;\n\t\tmirrorGradient?: boolean;\n\t\tspotlightRadius?: number;\n\t\tspotlightSoftness?: number;\n\t\tspotlightOpacity?: number;\n\t\tdistortAmount?: number;\n\t\tshineDirection?: 'left' | 'right';\n\t\tmixBlendMode?: string;\n\t}\n\n\tlet {\n\t\tclassName = '',\n\t\tdpr,\n\t\tpaused = false,\n\t\tgradientColors,\n\t\tangle = 0,\n\t\tnoise = 0.3,\n\t\tblindCount = 16,\n\t\tblindMinWidth = 60,\n\t\tmouseDampening = 0.15,\n\t\tmirrorGradient = false,\n\t\tspotlightRadius = 0.5,\n\t\tspotlightSoftness = 1,\n\t\tspotlightOpacity = 1,\n\t\tdistortAmount = 0,\n\t\tshineDirection = 'left',\n\t\tmixBlendMode = 'darken'\n\t}: GradientBlindsProps = $props();\n\n\tconst MAX_COLORS = 8;\n\n\tconst prepStops = (stops?: string[]) => {\n\t\tconst base = (stops && stops.length ? stops : ['#FF9FFC', '#5227FF']).slice(0, MAX_COLORS);\n\t\tif (base.length === 1) base.push(base[0]);\n\t\twhile (base.length < MAX_COLORS) base.push(base[base.length - 1]);\n\t\tconst arr: [number, number, number][] = [];\n\t\tfor (let i = 0; i < MAX_COLORS; i++) arr.push(ogl?.color.hexToArray(base[i]) || [1, 0, 1]);\n\t\tconst count = Math.max(2, Math.min(MAX_COLORS, stops?.length ?? 2));\n\t\treturn { arr, count };\n\t};\n\n\tlet ogl = $state<OglContext | null>(null);\n\tlet mouseTarget = $state([0, 0]);\n\tlet lastTime = 0;\n\tlet firstResize = $state(true);\n\n\t// Derived values\n\tconst colorData = $derived(prepStops(gradientColors));\n\n\t// Mouse interaction handler - convert normalized coords to canvas pixels like original\n\tconst handleMouseMove = ({ x, y, rect }: { x: number; y: number; rect: DOMRect }) => {\n\t\tif (!ogl?.gl) return;\n\t\tconst scale = dpr ?? (typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1);\n\t\t// Convert normalized coordinates (0-1) to canvas pixel coordinates\n\t\tconst canvasX = x * ogl.gl.canvas.width;\n\t\tconst canvasY = y * ogl.gl.canvas.height; // Don't flip Y - Canvas already provides correct coordinates\n\t\tmouseTarget = [canvasX, canvasY];\n\t};\n\tconst vertex = `\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\n\tconst fragment = `\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec3  iResolution;\nuniform vec2  iMouse;\nuniform float iTime;\n\nuniform float uAngle;\nuniform float uNoise;\nuniform float uBlindCount;\nuniform float uSpotlightRadius;\nuniform float uSpotlightSoftness;\nuniform float uSpotlightOpacity;\nuniform float uMirror;\nuniform float uDistort;\nuniform float uShineFlip;\nuniform vec3  uColor0;\nuniform vec3  uColor1;\nuniform vec3  uColor2;\nuniform vec3  uColor3;\nuniform vec3  uColor4;\nuniform vec3  uColor5;\nuniform vec3  uColor6;\nuniform vec3  uColor7;\nuniform int   uColorCount;\n\nvarying vec2 vUv;\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rotate2D(vec2 p, float a){\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, -s, s, c) * p;\n}\n\nvec3 getGradientColor(float t){\n  float tt = clamp(t, 0.0, 1.0);\n  int count = uColorCount;\n  if (count < 2) count = 2;\n  float scaled = tt * float(count - 1);\n  float seg = floor(scaled);\n  float f = fract(scaled);\n\n  if (seg < 1.0) return mix(uColor0, uColor1, f);\n  if (seg < 2.0 && count > 2) return mix(uColor1, uColor2, f);\n  if (seg < 3.0 && count > 3) return mix(uColor2, uColor3, f);\n  if (seg < 4.0 && count > 4) return mix(uColor3, uColor4, f);\n  if (seg < 5.0 && count > 5) return mix(uColor4, uColor5, f);\n  if (seg < 6.0 && count > 6) return mix(uColor5, uColor6, f);\n  if (seg < 7.0 && count > 7) return mix(uColor6, uColor7, f);\n  if (count > 7) return uColor7;\n  if (count > 6) return uColor6;\n  if (count > 5) return uColor5;\n  if (count > 4) return uColor4;\n  if (count > 3) return uColor3;\n  if (count > 2) return uColor2;\n  return uColor1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n\n    float aspect = iResolution.x / iResolution.y;\n    vec2 p = uv0 * 2.0 - 1.0;\n    p.x *= aspect;\n    vec2 pr = rotate2D(p, uAngle);\n    pr.x /= aspect;\n    vec2 uv = pr * 0.5 + 0.5;\n\n    vec2 uvMod = uv;\n    if (uDistort > 0.0) {\n      float a = uvMod.y * 6.0;\n      float b = uvMod.x * 6.0;\n      float w = 0.01 * uDistort;\n      uvMod.x += sin(a) * w;\n      uvMod.y += cos(b) * w;\n    }\n    float t = uvMod.x;\n    if (uMirror > 0.5) {\n      t = 1.0 - abs(1.0 - 2.0 * fract(t));\n    }\n    vec3 base = getGradientColor(t);\n\n    vec2 offset = vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);\n  float d = length(uv0 - offset);\n  float r = max(uSpotlightRadius, 1e-4);\n  float dn = d / r;\n  float spot = (1.0 - 2.0 * pow(dn, uSpotlightSoftness)) * uSpotlightOpacity;\n  vec3 cir = vec3(spot);\n  float stripe = fract(uvMod.x * max(uBlindCount, 1.0));\n  if (uShineFlip > 0.5) stripe = 1.0 - stripe;\n    vec3 ran = vec3(stripe);\n\n    vec3 col = cir + base - ran;\n    col += (rand(gl_FragCoord.xy + iTime) - 0.5) * uNoise;\n\n    fragColor = vec4(col, 1.0);\n}\n\nvoid main() {\n    vec4 color;\n    mainImage(color, vUv * iResolution.xy);\n    gl_FragColor = color;\n}\n`;\n</script>\n\n<Canvas\n\t{dpr}\n\talpha={true}\n\tantialias={true}\n\tbind:ogl\n\tonMouseMove={handleMouseMove}\n\tclass={className}\n>\n\t<!-- style:mix-blend-mode={mixBlendMode} -->\n\t<Program\n\t\t{vertex}\n\t\t{fragment}\n\t\tuniforms={{\n\t\t\tiTime: { value: 0 },\n\t\t\tiResolution: { value: [1, 1, 1], noUpdate: true },\n\t\t\tiMouse: { value: [0, 0] },\n\t\t\tuAngle: { value: (angle * Math.PI) / 180 },\n\t\t\tuNoise: { value: noise },\n\t\t\tuBlindCount: { value: Math.max(1, blindCount) },\n\t\t\tuSpotlightRadius: { value: spotlightRadius },\n\t\t\tuSpotlightSoftness: { value: spotlightSoftness },\n\t\t\tuSpotlightOpacity: { value: spotlightOpacity },\n\t\t\tuMirror: { value: mirrorGradient ? 1.0 : 0.0 },\n\t\t\tuDistort: { value: distortAmount },\n\t\t\tuShineFlip: { value: shineDirection === 'right' ? 1.0 : 0.0 },\n\t\t\tuColor0: { value: colorData.arr[0] || [1, 0, 1] },\n\t\t\tuColor1: { value: colorData.arr[1] || [0.32, 0.15, 1] },\n\t\t\tuColor2: { value: colorData.arr[2] || [0.32, 0.15, 1] },\n\t\t\tuColor3: { value: colorData.arr[3] || [0.32, 0.15, 1] },\n\t\t\tuColor4: { value: colorData.arr[4] || [0.32, 0.15, 1] },\n\t\t\tuColor5: { value: colorData.arr[5] || [0.32, 0.15, 1] },\n\t\t\tuColor6: { value: colorData.arr[6] || [0.32, 0.15, 1] },\n\t\t\tuColor7: { value: colorData.arr[7] || [0.32, 0.15, 1] },\n\t\t\tuColorCount: { value: colorData.count }\n\t\t}}\n\t\tonResize={({ width, height }, program) => {\n\t\t\t// Exact copy of original resize logic\n\t\t\tprogram.program.uniforms.iResolution.value = [width, height, 1];\n\n\t\t\tif (blindMinWidth && blindMinWidth > 0) {\n\t\t\t\tconst maxByMinWidth = Math.max(1, Math.floor(width / blindMinWidth));\n\t\t\t\tconst effective = blindCount ? Math.min(blindCount, maxByMinWidth) : maxByMinWidth;\n\t\t\t\tprogram.program.uniforms.uBlindCount.value = Math.max(1, effective);\n\t\t\t} else {\n\t\t\t\tprogram.program.uniforms.uBlindCount.value = Math.max(1, blindCount);\n\t\t\t}\n\n\t\t\tif (firstResize) {\n\t\t\t\tfirstResize = false;\n\t\t\t\tconst cx = width / 2;\n\t\t\t\tconst cy = height / 2;\n\t\t\t\tprogram.program.uniforms.iMouse.value = [cx, cy];\n\t\t\t\tmouseTarget = [cx, cy];\n\t\t\t}\n\t\t}}\n\t\tonUpdate={({ time }, { program }) => {\n\t\t\tif (paused) return;\n\n\t\t\t// Exact copy of original loop logic\n\t\t\tconst elapsed = time * 0.001;\n\t\t\tprogram.uniforms.iTime.value = elapsed;\n\n\t\t\tif (mouseDampening > 0) {\n\t\t\t\tif (!lastTime) lastTime = time;\n\t\t\t\tconst dt = (time - lastTime) / 1000;\n\t\t\t\tlastTime = time;\n\t\t\t\tconst tau = Math.max(1e-4, mouseDampening);\n\t\t\t\tlet factor = 1 - Math.exp(-dt / tau);\n\t\t\t\tif (factor > 1) factor = 1;\n\t\t\t\tconst target = mouseTarget;\n\t\t\t\tconst cur = program.uniforms.iMouse.value;\n\t\t\t\tcur[0] += (target[0] - cur[0]) * factor;\n\t\t\t\tcur[1] += (target[1] - cur[1]) * factor;\n\t\t\t} else {\n\t\t\t\tlastTime = time;\n\t\t\t}\n\n\t\t\t// Update blindCount reactively (respecting blindMinWidth if set)\n\t\t\tif (blindMinWidth && blindMinWidth > 0 && ogl?.gl) {\n\t\t\t\tconst maxByMinWidth = Math.max(1, Math.floor(ogl.gl.canvas.width / blindMinWidth));\n\t\t\t\tconst effective = blindCount ? Math.min(blindCount, maxByMinWidth) : maxByMinWidth;\n\t\t\t\tprogram.uniforms.uBlindCount.value = Math.max(1, effective);\n\t\t\t} else {\n\t\t\t\tprogram.uniforms.uBlindCount.value = Math.max(1, blindCount);\n\t\t\t}\n\t\t}}\n\t>\n\t\t<Triangle>\n\t\t\t<Mesh\n\t\t\t\tonUpdate={({ time }, mesh) => {\n\t\t\t\t\tmesh.ogl.renderer?.render({ scene: mesh.mesh });\n\t\t\t\t}}\n\t\t\t/>\n\t\t</Triangle>\n\t</Program>\n</Canvas>\n",
      "type": "registry:component"
    }
  ]
}