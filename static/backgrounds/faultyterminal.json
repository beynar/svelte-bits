{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "faultyterminal",
  "type": "registry:block",
  "title": "FaultyTerminal",
  "description": "FaultyTerminal background component",
  "dependencies": [
    "svogl",
    "ogl"
  ],
  "files": [
    {
      "path": "src/lib/backgrounds/FaultyTerminal/FaultyTerminal.svelte",
      "content": "<script lang=\"ts\">\n\timport { Canvas, Program, Mesh, Triangle, OglContext } from 'svogl';\n\t// @ts-ignore\n\timport { Vec2 } from 'ogl';\n\ttype Vec2 = [number, number];\n\n\tinterface FaultyTerminalProps {\n\t\tscale?: number;\n\t\tgridMul?: Vec2;\n\t\tdigitSize?: number;\n\t\ttimeScale?: number;\n\t\tpause?: boolean;\n\t\tscanlineIntensity?: number;\n\t\tglitchAmount?: number;\n\t\tflickerAmount?: number;\n\t\tnoiseAmp?: number;\n\t\tchromaticAberration?: number;\n\t\tdither?: number | boolean;\n\t\tcurvature?: number;\n\t\ttint?: string;\n\t\tmouseReact?: boolean;\n\t\tmouseStrength?: number;\n\t\tdpr?: number;\n\t\tpageLoadAnimation?: boolean;\n\t\tbrightness?: number;\n\t\tclass: string;\n\t}\n\n\tlet {\n\t\tscale = 1,\n\t\tgridMul = [2, 1] as Vec2,\n\t\tdigitSize = 1.5,\n\t\ttimeScale = 0.3,\n\t\tpause = false,\n\t\tscanlineIntensity = 0.3,\n\t\tglitchAmount = 1,\n\t\tflickerAmount = 1,\n\t\tnoiseAmp = 1,\n\t\tchromaticAberration = 0,\n\t\tdither = 0,\n\t\tcurvature = 0.2,\n\t\ttint = '#56d345',\n\t\tmouseReact = true,\n\t\tmouseStrength = 0.2,\n\t\tdpr = typeof window !== 'undefined' ? Math.min(window.devicePixelRatio || 1, 2) : 1,\n\t\tpageLoadAnimation = true,\n\t\tbrightness = 1,\n\t\tclass: className = ''\n\t}: FaultyTerminalProps = $props();\n\n\tconst vertex = `\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\n\tconst fragment = `\nprecision mediump float;\n\nvarying vec2 vUv;\n\nuniform float iTime;\nuniform vec3  iResolution;\nuniform float uScale;\n\nuniform vec2  uGridMul;\nuniform float uDigitSize;\nuniform float uScanlineIntensity;\nuniform float uGlitchAmount;\nuniform float uFlickerAmount;\nuniform float uNoiseAmp;\nuniform float uChromaticAberration;\nuniform float uDither;\nuniform float uCurvature;\nuniform vec3  uTint;\nuniform vec2  uMouse;\nuniform float uMouseStrength;\nuniform float uUseMouse;\nuniform float uPageLoadProgress;\nuniform float uUsePageLoadAnimation;\nuniform float uBrightness;\n\nfloat time;\n\nfloat hash21(vec2 p){\n  p = fract(p * 234.56);\n  p += dot(p, p + 34.56);\n  return fract(p.x * p.y);\n}\n\nfloat noise(vec2 p)\n{\n  return sin(p.x * 10.0) * sin(p.y * (3.0 + sin(time * 0.090909))) + 0.2; \n}\n\nmat2 rotate(float angle)\n{\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, -s, s, c);\n}\n\nfloat fbm(vec2 p)\n{\n  p *= 1.1;\n  float f = 0.0;\n  float amp = 0.5 * uNoiseAmp;\n  \n  mat2 modify0 = rotate(time * 0.02);\n  f += amp * noise(p);\n  p = modify0 * p * 2.0;\n  amp *= 0.454545; // 1/2.2\n  \n  mat2 modify1 = rotate(time * 0.02);\n  f += amp * noise(p);\n  p = modify1 * p * 2.0;\n  amp *= 0.454545;\n  \n  mat2 modify2 = rotate(time * 0.08);\n  f += amp * noise(p);\n  \n  return f;\n}\n\nfloat pattern(vec2 p, out vec2 q, out vec2 r) {\n  vec2 offset1 = vec2(1.0);\n  vec2 offset0 = vec2(0.0);\n  mat2 rot01 = rotate(0.1 * time);\n  mat2 rot1 = rotate(0.1);\n  \n  q = vec2(fbm(p + offset1), fbm(rot01 * p + offset1));\n  r = vec2(fbm(rot1 * q + offset0), fbm(q + offset0));\n  return fbm(p + r);\n}\n\nfloat digit(vec2 p){\n    vec2 grid = uGridMul * 15.0;\n    vec2 s = floor(p * grid) / grid;\n    p = p * grid;\n    vec2 q, r;\n    float intensity = pattern(s * 0.1, q, r) * 1.3 - 0.03;\n    \n    if(uUseMouse > 0.5){\n        vec2 mouseWorld = uMouse * uScale;\n        float distToMouse = distance(s, mouseWorld);\n        float mouseInfluence = exp(-distToMouse * 8.0) * uMouseStrength * 10.0;\n        intensity += mouseInfluence;\n        \n        float ripple = sin(distToMouse * 20.0 - iTime * 5.0) * 0.1 * mouseInfluence;\n        intensity += ripple;\n    }\n    \n    if(uUsePageLoadAnimation > 0.5){\n        float cellRandom = fract(sin(dot(s, vec2(12.9898, 78.233))) * 43758.5453);\n        float cellDelay = cellRandom * 0.8;\n        float cellProgress = clamp((uPageLoadProgress - cellDelay) / 0.2, 0.0, 1.0);\n        \n        float fadeAlpha = smoothstep(0.0, 1.0, cellProgress);\n        intensity *= fadeAlpha;\n    }\n    \n    p = fract(p);\n    p *= uDigitSize;\n    \n    float px5 = p.x * 5.0;\n    float py5 = (1.0 - p.y) * 5.0;\n    float x = fract(px5);\n    float y = fract(py5);\n    \n    float i = floor(py5) - 2.0;\n    float j = floor(px5) - 2.0;\n    float n = i * i + j * j;\n    float f = n * 0.0625;\n    \n    float isOn = step(0.1, intensity - f);\n    float brightness = isOn * (0.2 + y * 0.8) * (0.75 + x * 0.25);\n    \n    return step(0.0, p.x) * step(p.x, 1.0) * step(0.0, p.y) * step(p.y, 1.0) * brightness;\n}\n\nfloat onOff(float a, float b, float c)\n{\n\treturn step(c, sin(iTime + a * cos(iTime * b))) * uFlickerAmount;\n}\n\nfloat displace(vec2 look)\n{\n    float y = look.y - mod(iTime * 0.25, 1.0);\n    float window = 1.0 / (1.0 + 50.0 * y * y);\n\t  return sin(look.y * 20.0 + iTime) * 0.0125 * onOff(4.0, 2.0, 0.8) * (1.0 + cos(iTime * 60.0)) * window;\n}\n\nvec3 getColor(vec2 p){\n    \n    float bar = step(mod(p.y + time * 20.0, 1.0), 0.2) * 0.4 + 1.0; // more efficient than ternary\n    bar *= uScanlineIntensity;\n    \n    float displacement = displace(p);\n    p.x += displacement;\n\n    if (uGlitchAmount != 1.0) {\n      float extra = displacement * (uGlitchAmount - 1.0);\n      p.x += extra;\n    }\n\n    float middle = digit(p);\n    \n    const float off = 0.002;\n    float sum = digit(p + vec2(-off, -off)) + digit(p + vec2(0.0, -off)) + digit(p + vec2(off, -off)) +\n                digit(p + vec2(-off, 0.0)) + digit(p + vec2(0.0, 0.0)) + digit(p + vec2(off, 0.0)) +\n                digit(p + vec2(-off, off)) + digit(p + vec2(0.0, off)) + digit(p + vec2(off, off));\n    \n    vec3 baseColor = vec3(0.9) * middle + sum * 0.1 * vec3(1.0) * bar;\n    return baseColor;\n}\n\nvec2 barrel(vec2 uv){\n  vec2 c = uv * 2.0 - 1.0;\n  float r2 = dot(c, c);\n  c *= 1.0 + uCurvature * r2;\n  return c * 0.5 + 0.5;\n}\n\nvoid main() {\n    time = iTime * 0.333333;\n    vec2 uv = vUv;\n\n    if(uCurvature != 0.0){\n      uv = barrel(uv);\n    }\n    \n    vec2 p = uv * uScale;\n    vec3 col = getColor(p);\n\n    if(uChromaticAberration != 0.0){\n      vec2 ca = vec2(uChromaticAberration) / iResolution.xy;\n      col.r = getColor(p + ca).r;\n      col.b = getColor(p - ca).b;\n    }\n\n    col *= uTint;\n    col *= uBrightness;\n\n    if(uDither > 0.0){\n      float rnd = hash21(gl_FragCoord.xy);\n      col += (rnd - 0.5) * (uDither * 0.003922);\n    }\n\n    gl_FragColor = vec4(col, 1.0);\n}\n`;\n\n\tfunction hexToRgb(hex: string): [number, number, number] {\n\t\tlet h = hex.replace('#', '').trim();\n\t\tif (h.length === 3)\n\t\t\th = h\n\t\t\t\t.split('')\n\t\t\t\t.map((c) => c + c)\n\t\t\t\t.join('');\n\t\tconst num = parseInt(h, 16);\n\t\treturn [((num >> 16) & 255) / 255, ((num >> 8) & 255) / 255, (num & 255) / 255];\n\t}\n\n\tlet ogl = $state<OglContext | null>(null);\n\tlet mousePos = $state([0.5, 0.5]);\n\tlet smoothMousePos = $state([0.5, 0.5]);\n\tlet frozenTime = $state(0);\n\tlet loadAnimationStart = $state(0);\n\tlet timeOffset = $state(Math.random() * 100);\n\tlet pageLoadProgress = $state(pageLoadAnimation ? 0 : 1);\n\n\t// Derived values\n\tconst tintVec = $derived(hexToRgb(tint));\n\tconst ditherValue = $derived(typeof dither === 'boolean' ? (dither ? 1 : 0) : dither);\n\n\t// Mouse smoothing effect\n\t$effect(() => {\n\t\tif (!mouseReact) return;\n\t\tconst dampingFactor = 0.08;\n\t\tsmoothMousePos[0] += (mousePos[0] - smoothMousePos[0]) * dampingFactor;\n\t\tsmoothMousePos[1] += (mousePos[1] - smoothMousePos[1]) * dampingFactor;\n\t});\n</script>\n\n<Canvas\n\tbind:ogl\n\tclass={className}\n\t{dpr}\n\tonMouseMove={mouseReact\n\t\t? ({ x, y }) => {\n\t\t\t\tmousePos = [x, y];\n\t\t\t}\n\t\t: undefined}\n\tonMount={() => {\n\t\tloadAnimationStart = performance.now();\n\t}}\n>\n\t<Program\n\t\tonResize={({ width, height }, program) => {\n\t\t\tprogram.program.uniforms.iResolution.value = [width, height, width / height];\n\t\t}}\n\t\t{vertex}\n\t\t{fragment}\n\t\tuniforms={{\n\t\t\tiTime: { value: 0 },\n\t\t\tiResolution: { value: [0, 0, 0] },\n\t\t\tuScale: { value: scale },\n\t\t\tuGridMul: { value: gridMul },\n\t\t\tuDigitSize: { value: digitSize },\n\t\t\tuScanlineIntensity: { value: scanlineIntensity },\n\t\t\tuGlitchAmount: { value: glitchAmount },\n\t\t\tuFlickerAmount: { value: flickerAmount },\n\t\t\tuNoiseAmp: { value: noiseAmp },\n\t\t\tuChromaticAberration: { value: chromaticAberration },\n\t\t\tuDither: { value: ditherValue },\n\t\t\tuCurvature: { value: curvature },\n\t\t\tuTint: { value: tintVec },\n\t\t\tuMouse: { value: smoothMousePos },\n\t\t\tuMouseStrength: { value: mouseStrength },\n\t\t\tuUseMouse: { value: mouseReact ? 1 : 0 },\n\t\t\tuPageLoadProgress: { value: pageLoadProgress },\n\t\t\tuUsePageLoadAnimation: { value: pageLoadAnimation ? 1 : 0 },\n\t\t\tuBrightness: { value: brightness }\n\t\t}}\n\t\tonUpdate={({ time }, program) => {\n\t\t\t// Handle page load animation\n\t\t\tif (pageLoadAnimation && loadAnimationStart > 0) {\n\t\t\t\tconst animationDuration = 2000;\n\t\t\t\tconst animationElapsed = performance.now() - loadAnimationStart;\n\t\t\t\tpageLoadProgress = Math.min(animationElapsed / animationDuration, 1);\n\t\t\t}\n\n\t\t\t// Handle time\n\t\t\tif (!pause) {\n\t\t\t\tconst elapsed = (time * 0.001 + timeOffset) * timeScale;\n\t\t\t\tprogram.program.uniforms.iTime.value = elapsed;\n\t\t\t\tfrozenTime = elapsed;\n\t\t\t} else {\n\t\t\t\tprogram.program.uniforms.iTime.value = frozenTime;\n\t\t\t}\n\t\t}}\n\t>\n\t\t<Triangle>\n\t\t\t<Mesh\n\t\t\t\tonUpdate={({ time }, mesh) => {\n\t\t\t\t\tmesh.ogl.renderer?.render({ scene: mesh.mesh });\n\t\t\t\t}}\n\t\t\t/>\n\t\t</Triangle>\n\t</Program>\n</Canvas>\n",
      "type": "registry:component"
    }
  ]
}