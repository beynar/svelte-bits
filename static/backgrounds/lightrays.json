{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "lightrays",
  "type": "registry:block",
  "title": "LightRays",
  "description": "LightRays background component",
  "dependencies": [
    "svogl"
  ],
  "files": [
    {
      "path": "src/lib/backgrounds/LightRays/LightRays.svelte",
      "content": "<script lang=\"ts\">\n\timport { Canvas, OglContext, Program, Mesh, Triangle } from 'svogl';\n\n\texport type RaysOrigin =\n\t\t| 'top-center'\n\t\t| 'top-left'\n\t\t| 'top-right'\n\t\t| 'right'\n\t\t| 'left'\n\t\t| 'bottom-center'\n\t\t| 'bottom-right'\n\t\t| 'bottom-left';\n\n\tinterface LightRaysProps {\n\t\traysOrigin?: RaysOrigin;\n\t\traysColor?: string;\n\t\traysSpeed?: number;\n\t\tlightSpread?: number;\n\t\trayLength?: number;\n\t\tpulsating?: boolean;\n\t\tfadeDistance?: number;\n\t\tsaturation?: number;\n\t\tfollowMouse?: boolean;\n\t\tmouseInfluence?: number;\n\t\tnoiseAmount?: number;\n\t\tdistortion?: number;\n\t\tclassName?: string;\n\t}\n\n\tlet {\n\t\traysOrigin = 'top-center',\n\t\traysColor = '#ffffff',\n\t\traysSpeed = 1,\n\t\tlightSpread = 1,\n\t\trayLength = 2,\n\t\tpulsating = false,\n\t\tfadeDistance = 1.0,\n\t\tsaturation = 1.0,\n\t\tfollowMouse = true,\n\t\tmouseInfluence = 0.1,\n\t\tnoiseAmount = 0.0,\n\t\tdistortion = 0.0,\n\t\tclassName = ''\n\t}: LightRaysProps = $props();\n\n\tlet ogl = $state<OglContext | null>(null);\n\tlet mousePos = $state([0.5, 0.5]);\n\tlet smoothMousePos = $state([0.5, 0.5]);\n\n\tconst getAnchorAndDir = (\n\t\torigin: RaysOrigin,\n\t\tw: number,\n\t\th: number\n\t): { anchor: [number, number]; dir: [number, number] } => {\n\t\tconst outside = 0.2;\n\t\tswitch (origin) {\n\t\t\tcase 'top-left':\n\t\t\t\treturn { anchor: [0, -outside * h], dir: [0, 1] };\n\t\t\tcase 'top-right':\n\t\t\t\treturn { anchor: [w, -outside * h], dir: [0, 1] };\n\t\t\tcase 'left':\n\t\t\t\treturn { anchor: [-outside * w, 0.5 * h], dir: [1, 0] };\n\t\t\tcase 'right':\n\t\t\t\treturn { anchor: [(1 + outside) * w, 0.5 * h], dir: [-1, 0] };\n\t\t\tcase 'bottom-left':\n\t\t\t\treturn { anchor: [0, (1 + outside) * h], dir: [0, -1] };\n\t\t\tcase 'bottom-center':\n\t\t\t\treturn { anchor: [0.5 * w, (1 + outside) * h], dir: [0, -1] };\n\t\t\tcase 'bottom-right':\n\t\t\t\treturn { anchor: [w, (1 + outside) * h], dir: [0, -1] };\n\t\t\tdefault: // \"top-center\"\n\t\t\t\treturn { anchor: [0.5 * w, -outside * h], dir: [0, 1] };\n\t\t}\n\t};\n\n\t// Mouse interaction handler\n\tconst handleMouseMove = ({ x, y }: { x: number; y: number }) => {\n\t\tif (followMouse) {\n\t\t\tmousePos = [x, y];\n\t\t}\n\t};\n\n\tconst vertex = `\nattribute vec2 position;\nvarying vec2 vUv;\nvoid main() {\n  vUv = position * 0.5 + 0.5;\n  gl_Position = vec4(position, 0.0, 1.0);\n}`;\n\n\tconst fragment = `precision highp float;\n\nuniform float iTime;\nuniform vec2  iResolution;\n\nuniform vec2  rayPos;\nuniform vec2  rayDir;\nuniform vec3  raysColor;\nuniform float raysSpeed;\nuniform float lightSpread;\nuniform float rayLength;\nuniform float pulsating;\nuniform float fadeDistance;\nuniform float saturation;\nuniform vec2  mousePos;\nuniform float mouseInfluence;\nuniform float noiseAmount;\nuniform float distortion;\n\nvarying vec2 vUv;\n\nfloat noise(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord,\n                  float seedA, float seedB, float speed) {\n  vec2 sourceToCoord = coord - raySource;\n  vec2 dirNorm = normalize(sourceToCoord);\n  float cosAngle = dot(dirNorm, rayRefDirection);\n\n  float distortedAngle = cosAngle + distortion * sin(iTime * 2.0 + length(sourceToCoord) * 0.01) * 0.2;\n  \n  float spreadFactor = pow(max(distortedAngle, 0.0), 1.0 / max(lightSpread, 0.001));\n\n  float distance = length(sourceToCoord);\n  float maxDistance = iResolution.x * rayLength;\n  float lengthFalloff = clamp((maxDistance - distance) / maxDistance, 0.0, 1.0);\n  \n  float fadeFalloff = clamp((iResolution.x * fadeDistance - distance) / (iResolution.x * fadeDistance), 0.5, 1.0);\n  float pulse = pulsating > 0.5 ? (0.8 + 0.2 * sin(iTime * speed * 3.0)) : 1.0;\n\n  float baseStrength = clamp(\n    (0.45 + 0.15 * sin(distortedAngle * seedA + iTime * speed)) +\n    (0.3 + 0.2 * cos(-distortedAngle * seedB + iTime * speed)),\n    0.0, 1.0\n  );\n\n  return baseStrength * lengthFalloff * fadeFalloff * spreadFactor * pulse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 coord = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n  \n  vec2 finalRayDir = rayDir;\n  if (mouseInfluence > 0.0) {\n    vec2 mouseScreenPos = mousePos * iResolution.xy;\n    vec2 mouseDirection = normalize(mouseScreenPos - rayPos);\n    finalRayDir = normalize(mix(rayDir, mouseDirection, mouseInfluence));\n  }\n\n  vec4 rays1 = vec4(1.0) *\n               rayStrength(rayPos, finalRayDir, coord, 36.2214, 21.11349,\n                           1.5 * raysSpeed);\n  vec4 rays2 = vec4(1.0) *\n               rayStrength(rayPos, finalRayDir, coord, 22.3991, 18.0234,\n                           1.1 * raysSpeed);\n\n  fragColor = rays1 * 0.5 + rays2 * 0.4;\n\n  if (noiseAmount > 0.0) {\n    float n = noise(coord * 0.01 + iTime * 0.1);\n    fragColor.rgb *= (1.0 - noiseAmount + noiseAmount * n);\n  }\n\n  float brightness = 1.0 - (coord.y / iResolution.y);\n  fragColor.x *= 0.1 + brightness * 0.8;\n  fragColor.y *= 0.3 + brightness * 0.6;\n  fragColor.z *= 0.5 + brightness * 0.5;\n\n  if (saturation != 1.0) {\n    float gray = dot(fragColor.rgb, vec3(0.299, 0.587, 0.114));\n    fragColor.rgb = mix(vec3(gray), fragColor.rgb, saturation);\n  }\n\n  fragColor.rgb *= raysColor;\n}\n\nvoid main() {\n  vec4 color;\n  mainImage(color, gl_FragCoord.xy);\n  gl_FragColor  = color;\n}`;\n</script>\n\n<Canvas\n\tbind:ogl\n\tonMouseMove={handleMouseMove}\n\tclass=\"light-rays-container {className}\"\n\talpha={true}\n\tdpr={typeof window !== 'undefined' ? Math.min(window.devicePixelRatio, 2) : 1}\n>\n\t<Program\n\t\t{vertex}\n\t\t{fragment}\n\t\tuniforms={{\n\t\t\tiTime: { value: 0 },\n\t\t\tiResolution: { value: [1, 1], noUpdate: true },\n\t\t\trayPos: { value: [0, 0] },\n\t\t\trayDir: { value: [0, 1] },\n\t\t\traysColor: { value: ogl?.color.hexToArray(raysColor) },\n\t\t\traysSpeed: { value: raysSpeed },\n\t\t\tlightSpread: { value: lightSpread },\n\t\t\trayLength: { value: rayLength },\n\t\t\tpulsating: { value: pulsating ? 1.0 : 0.0 },\n\t\t\tfadeDistance: { value: fadeDistance },\n\t\t\tsaturation: { value: saturation },\n\t\t\tmousePos: { value: smoothMousePos },\n\t\t\tmouseInfluence: { value: mouseInfluence },\n\t\t\tnoiseAmount: { value: noiseAmount },\n\t\t\tdistortion: { value: distortion }\n\t\t}}\n\t\tonResize={({ width, height }, program) => {\n\t\t\tconst dpr = ogl?.gl ? Math.min(window.devicePixelRatio, 2) : 1;\n\t\t\tconst w = width * dpr;\n\t\t\tconst h = height * dpr;\n\n\t\t\tprogram.program.uniforms.iResolution.value = [w, h];\n\n\t\t\tconst { anchor, dir } = getAnchorAndDir(raysOrigin, w, h);\n\t\t\tprogram.program.uniforms.rayPos.value = anchor;\n\t\t\tprogram.program.uniforms.rayDir.value = dir;\n\t\t}}\n\t\tonUpdate={({ time }, { program }) => {\n\t\t\t// Update time\n\t\t\tprogram.uniforms.iTime.value = time * 0.001;\n\n\t\t\t// Mouse smoothing like original\n\t\t\tif (followMouse && mouseInfluence > 0.0) {\n\t\t\t\tconst smoothing = 0.92;\n\t\t\t\tsmoothMousePos[0] = smoothMousePos[0] * smoothing + mousePos[0] * (1 - smoothing);\n\t\t\t\tsmoothMousePos[1] = smoothMousePos[1] * smoothing + mousePos[1] * (1 - smoothing);\n\t\t\t\tprogram.uniforms.mousePos.value = smoothMousePos;\n\t\t\t}\n\n\t\t\t// Update ray position and direction based on origin\n\t\t\tif (ogl?.gl) {\n\t\t\t\tconst dpr = Math.min(window.devicePixelRatio, 2);\n\t\t\t\tconst w = ogl.gl.canvas.width;\n\t\t\t\tconst h = ogl.gl.canvas.height;\n\t\t\t\tconst { anchor, dir } = getAnchorAndDir(raysOrigin, w, h);\n\t\t\t\tprogram.uniforms.rayPos.value = anchor;\n\t\t\t\tprogram.uniforms.rayDir.value = dir;\n\t\t\t}\n\t\t}}\n\t>\n\t\t<Triangle>\n\t\t\t<Mesh\n\t\t\t\tonUpdate={({ time }, mesh) => {\n\t\t\t\t\tmesh.ogl.renderer?.render({ scene: mesh.mesh });\n\t\t\t\t}}\n\t\t\t/>\n\t\t</Triangle>\n\t</Program>\n</Canvas>\n\n<style>\n\t.light-rays-container {\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tdisplay: block;\n\t}\n</style>\n",
      "type": "registry:component"
    }
  ]
}