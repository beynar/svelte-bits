{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ripplegrid",
  "type": "registry:block",
  "title": "RippleGrid",
  "description": "RippleGrid background component",
  "dependencies": [
    "svogl"
  ],
  "files": [
    {
      "path": "src/lib/backgrounds/RippleGrid/RippleGrid.svelte",
      "content": "<script lang=\"ts\">\n\timport { Canvas, OglContext, Program, Mesh, Triangle } from 'svogl';\n\n\tinterface RippleGridProps {\n\t\tenableRainbow?: boolean;\n\t\tgridColor?: string;\n\t\trippleIntensity?: number;\n\t\tgridSize?: number;\n\t\tgridThickness?: number;\n\t\tfadeDistance?: number;\n\t\tvignetteStrength?: number;\n\t\tglowIntensity?: number;\n\t\topacity?: number;\n\t\tgridRotation?: number;\n\t\tmouseInteraction?: boolean;\n\t\tmouseInteractionRadius?: number;\n\t\tclass: string;\n\t}\n\n\tlet {\n\t\tenableRainbow = false,\n\t\tgridColor = '#ffffff',\n\t\trippleIntensity = 0.05,\n\t\tgridSize = 10.0,\n\t\tgridThickness = 15.0,\n\t\tfadeDistance = 1.5,\n\t\tvignetteStrength = 2.0,\n\t\tglowIntensity = 0.1,\n\t\topacity = 1.0,\n\t\tgridRotation = 0,\n\t\tmouseInteraction = true,\n\t\tmouseInteractionRadius = 1,\n\t\tclass: className = ''\n\t}: RippleGridProps = $props();\n\n\tconst vertex = `#version 300 es\nin vec2 position;\nout vec2 vUv;\nvoid main() {\n    vUv = position * 0.5 + 0.5;\n    gl_Position = vec4(position, 0.0, 1.0);\n}`;\n\n\tconst fragment = `#version 300 es\nprecision highp float;\nuniform float iTime;\nuniform vec2 iResolution;\nuniform bool enableRainbow;\nuniform vec3 gridColor;\nuniform float rippleIntensity;\nuniform float gridSize;\nuniform float gridThickness;\nuniform float fadeDistance;\nuniform float vignetteStrength;\nuniform float glowIntensity;\nuniform float opacity;\nuniform float gridRotation;\nuniform bool mouseInteraction;\nuniform vec2 mousePosition;\nuniform float mouseInfluence;\nuniform float mouseInteractionRadius;\nin vec2 vUv;\nout vec4 fragColor;\n\nfloat pi = 3.141592;\n\nmat2 rotate(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvoid main() {\n    vec2 uv = vUv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    if (gridRotation != 0.0) {\n        uv = rotate(gridRotation * pi / 180.0) * uv;\n    }\n\n    float dist = length(uv);\n    float func = sin(pi * (iTime - dist));\n    vec2 rippleUv = uv + uv * func * rippleIntensity;\n\n    if (mouseInteraction && mouseInfluence > 0.0) {\n        vec2 mouseUv = (mousePosition * 2.0 - 1.0);\n        mouseUv.x *= iResolution.x / iResolution.y;\n        float mouseDist = length(uv - mouseUv);\n        \n        float influence = mouseInfluence * exp(-mouseDist * mouseDist / (mouseInteractionRadius * mouseInteractionRadius));\n        \n        float mouseWave = sin(pi * (iTime * 2.0 - mouseDist * 3.0)) * influence;\n        rippleUv += normalize(uv - mouseUv) * mouseWave * rippleIntensity * 0.3;\n    }\n\n    vec2 a = sin(gridSize * 0.5 * pi * rippleUv - pi / 2.0);\n    vec2 b = abs(a);\n\n    float aaWidth = 0.5;\n    vec2 smoothB = vec2(\n        smoothstep(0.0, aaWidth, b.x),\n        smoothstep(0.0, aaWidth, b.y)\n    );\n\n    vec3 color = vec3(0.0);\n    color += exp(-gridThickness * smoothB.x * (0.8 + 0.5 * sin(pi * iTime)));\n    color += exp(-gridThickness * smoothB.y);\n    color += 0.5 * exp(-(gridThickness / 4.0) * sin(smoothB.x));\n    color += 0.5 * exp(-(gridThickness / 3.0) * smoothB.y);\n\n    if (glowIntensity > 0.0) {\n        color += glowIntensity * exp(-gridThickness * 0.5 * smoothB.x);\n        color += glowIntensity * exp(-gridThickness * 0.5 * smoothB.y);\n    }\n\n    float ddd = exp(-2.0 * clamp(pow(dist, fadeDistance), 0.0, 1.0));\n    \n    vec2 vignetteCoords = vUv - 0.5;\n    float vignetteDistance = length(vignetteCoords);\n    float vignette = 1.0 - pow(vignetteDistance * 2.0, vignetteStrength);\n    vignette = clamp(vignette, 0.0, 1.0);\n    \n    vec3 t;\n    if (enableRainbow) {\n        t = vec3(\n            uv.x * 0.5 + 0.5 * sin(iTime),\n            uv.y * 0.5 + 0.5 * cos(iTime),\n            pow(cos(iTime), 4.0)\n        ) + 0.5;\n    } else {\n        t = gridColor;\n    }\n\n    float finalFade = ddd * vignette;\n    float alpha = length(color) * finalFade * opacity;\n    fragColor = vec4(color * t * finalFade * opacity, alpha);\n}`;\n\n\tlet ogl: OglContext | null = null;\n\tlet mousePosition = [0.5, 0.5];\n\tlet targetMouse = [0.5, 0.5];\n\tlet mouseInfluence = 0;\n\n\t// Mouse interaction handlers\n\tconst handleMouseMove = ({ x, y }: { x: number; y: number }) => {\n\t\tif (!mouseInteraction) return;\n\t\ttargetMouse = [x, 1.0 - y]; // Flip Y coordinate\n\t};\n\n\tconst handleMouseEnter = () => {\n\t\tif (!mouseInteraction) return;\n\t\tmouseInfluence = 1.0;\n\t};\n\n\tconst handleMouseLeave = () => {\n\t\tif (!mouseInteraction) return;\n\t\tmouseInfluence = 0.0;\n\t};\n</script>\n\n<Canvas\n\tbind:ogl\n\tclass={className}\n\talpha={true}\n\tdpr={typeof window !== 'undefined' ? Math.min(window.devicePixelRatio, 2) : 1}\n\tonMouseMove={handleMouseMove}\n\tonMouseEnter={handleMouseEnter}\n\tonMouseLeave={handleMouseLeave}\n\tonMount={(ogl) => {\n\t\t// Enable blending for transparency\n\t\togl.gl.enable(ogl.gl.BLEND);\n\t\togl.gl.blendFunc(ogl.gl.SRC_ALPHA, ogl.gl.ONE_MINUS_SRC_ALPHA);\n\t}}\n>\n\t{#snippet children(ogl)}\n\t\t{#if ogl.container}\n\t\t\t<Program\n\t\t\t\tonResize={({ width, height }, program) => {\n\t\t\t\t\tprogram.program.uniforms.iResolution.value = [width, height];\n\t\t\t\t}}\n\t\t\t\t{vertex}\n\t\t\t\t{fragment}\n\t\t\t\tuniforms={{\n\t\t\t\t\tiTime: { value: 0 },\n\t\t\t\t\tiResolution: {\n\t\t\t\t\t\tvalue: [ogl.container.offsetWidth, ogl.container.offsetHeight],\n\t\t\t\t\t\tnoUpdate: true\n\t\t\t\t\t},\n\t\t\t\t\tenableRainbow: { value: enableRainbow },\n\t\t\t\t\tgridColor: { value: ogl.color.hexToArray(gridColor) },\n\t\t\t\t\trippleIntensity: { value: rippleIntensity },\n\t\t\t\t\tgridSize: { value: gridSize },\n\t\t\t\t\tgridThickness: { value: gridThickness },\n\t\t\t\t\tfadeDistance: { value: fadeDistance },\n\t\t\t\t\tvignetteStrength: { value: vignetteStrength },\n\t\t\t\t\tglowIntensity: { value: glowIntensity },\n\t\t\t\t\topacity: { value: opacity },\n\t\t\t\t\tgridRotation: { value: gridRotation },\n\t\t\t\t\tmouseInteraction: { value: mouseInteraction },\n\t\t\t\t\tmousePosition: { value: [0.5, 0.5] },\n\t\t\t\t\tmouseInfluence: { value: 0 },\n\t\t\t\t\tmouseInteractionRadius: { value: mouseInteractionRadius }\n\t\t\t\t}}\n\t\t\t\tonUpdate={({ time }, program) => {\n\t\t\t\t\tprogram.program.uniforms.iTime.value = time * 0.001;\n\t\t\t\t\t// Smooth mouse position and influence updates\n\t\t\t\t\tconst lerpFactor = 0.1;\n\t\t\t\t\tmousePosition[0] += (targetMouse[0] - mousePosition[0]) * lerpFactor;\n\t\t\t\t\tmousePosition[1] += (targetMouse[1] - mousePosition[1]) * lerpFactor;\n\n\t\t\t\t\tconst currentInfluence = program.program.uniforms.mouseInfluence.value;\n\t\t\t\t\tprogram.program.uniforms.mouseInfluence.value +=\n\t\t\t\t\t\t(mouseInfluence - currentInfluence) * 0.05;\n\n\t\t\t\t\tprogram.program.uniforms.mousePosition.value = mousePosition;\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<Triangle>\n\t\t\t\t\t<Mesh\n\t\t\t\t\t\tonUpdate={({ time }, mesh) => {\n\t\t\t\t\t\t\tmesh.ogl.renderer?.render({ scene: mesh.mesh });\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t</Triangle>\n\t\t\t</Program>\n\t\t{/if}\n\t{/snippet}\n</Canvas>\n",
      "type": "registry:component"
    }
  ]
}