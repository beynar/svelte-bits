{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "orb",
  "type": "registry:block",
  "title": "Orb",
  "description": "Orb background component",
  "dependencies": [
    "svogl"
  ],
  "files": [
    {
      "path": "src/lib/backgrounds/Orb/Orb.svelte",
      "content": "<script lang=\"ts\">\n\timport { Canvas, OglContext, Program, Mesh, Triangle } from 'svogl';\n\n\tinterface OrbProps {\n\t\thue?: number;\n\t\thoverIntensity?: number;\n\t\trotateOnHover?: boolean;\n\t\tforceHoverState?: boolean;\n\t\tclassName?: string;\n\t}\n\n\tlet {\n\t\thue = 0,\n\t\thoverIntensity = 0.2,\n\t\trotateOnHover = true,\n\t\tforceHoverState = false,\n\t\tclassName = ''\n\t}: OrbProps = $props();\n\n\tlet ogl = $state<OglContext | null>(null);\n\tlet targetHover = $state(0);\n\tlet currentHover = $state(0);\n\tlet currentRot = $state(0);\n\tlet lastTime = 0;\n\tconst rotationSpeed = 0.3;\n\n\t// Hover detection handler\n\tconst handleMouseMove = ({ x, y, rect }: { x: number; y: number; rect: DOMRect }) => {\n\t\tconst width = rect.width;\n\t\tconst height = rect.height;\n\t\tconst size = Math.min(width, height);\n\t\tconst centerX = width / 2;\n\t\tconst centerY = height / 2;\n\t\tconst mouseX = x * width;\n\t\tconst mouseY = y * height;\n\t\tconst uvX = ((mouseX - centerX) / size) * 2.0;\n\t\tconst uvY = ((mouseY - centerY) / size) * 2.0;\n\n\t\tif (Math.sqrt(uvX * uvX + uvY * uvY) < 0.8) {\n\t\t\ttargetHover = 1;\n\t\t} else {\n\t\t\ttargetHover = 0;\n\t\t}\n\t};\n\n\tconst vertex = /* glsl */ `\n    precision highp float;\n    attribute vec2 position;\n    attribute vec2 uv;\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = vec4(position, 0.0, 1.0);\n    }\n  `;\n\n\tconst fragment = /* glsl */ `\n    precision highp float;\n\n    uniform float iTime;\n    uniform vec3 iResolution;\n    uniform float hue;\n    uniform float hover;\n    uniform float rot;\n    uniform float hoverIntensity;\n    varying vec2 vUv;\n\n    vec3 rgb2yiq(vec3 c) {\n      float y = dot(c, vec3(0.299, 0.587, 0.114));\n      float i = dot(c, vec3(0.596, -0.274, -0.322));\n      float q = dot(c, vec3(0.211, -0.523, 0.312));\n      return vec3(y, i, q);\n    }\n    \n    vec3 yiq2rgb(vec3 c) {\n      float r = c.x + 0.956 * c.y + 0.621 * c.z;\n      float g = c.x - 0.272 * c.y - 0.647 * c.z;\n      float b = c.x - 1.106 * c.y + 1.703 * c.z;\n      return vec3(r, g, b);\n    }\n    \n    vec3 adjustHue(vec3 color, float hueDeg) {\n      float hueRad = hueDeg * 3.14159265 / 180.0;\n      vec3 yiq = rgb2yiq(color);\n      float cosA = cos(hueRad);\n      float sinA = sin(hueRad);\n      float i = yiq.y * cosA - yiq.z * sinA;\n      float q = yiq.y * sinA + yiq.z * cosA;\n      yiq.y = i;\n      yiq.z = q;\n      return yiq2rgb(yiq);\n    }\n    \n    vec3 hash33(vec3 p3) {\n      p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\n      p3 += dot(p3, p3.yxz + 19.19);\n      return -1.0 + 2.0 * fract(vec3(\n        p3.x + p3.y,\n        p3.x + p3.z,\n        p3.y + p3.z\n      ) * p3.zyx);\n    }\n    \n    float snoise3(vec3 p) {\n      const float K1 = 0.333333333;\n      const float K2 = 0.166666667;\n      vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n      vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n      vec3 e = step(vec3(0.0), d0 - d0.yzx);\n      vec3 i1 = e * (1.0 - e.zxy);\n      vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n      vec3 d1 = d0 - (i1 - K2);\n      vec3 d2 = d0 - (i2 - K1);\n      vec3 d3 = d0 - 0.5;\n      vec4 h = max(0.6 - vec4(\n        dot(d0, d0),\n        dot(d1, d1),\n        dot(d2, d2),\n        dot(d3, d3)\n      ), 0.0);\n      vec4 n = h * h * h * h * vec4(\n        dot(d0, hash33(i)),\n        dot(d1, hash33(i + i1)),\n        dot(d2, hash33(i + i2)),\n        dot(d3, hash33(i + 1.0))\n      );\n      return dot(vec4(31.316), n);\n    }\n    \n    vec4 extractAlpha(vec3 colorIn) {\n      float a = max(max(colorIn.r, colorIn.g), colorIn.b);\n      return vec4(colorIn.rgb / (a + 1e-5), a);\n    }\n    \n    const vec3 baseColor1 = vec3(0.611765, 0.262745, 0.996078);\n    const vec3 baseColor2 = vec3(0.298039, 0.760784, 0.913725);\n    const vec3 baseColor3 = vec3(0.062745, 0.078431, 0.600000);\n    const float innerRadius = 0.6;\n    const float noiseScale = 0.65;\n    \n    float light1(float intensity, float attenuation, float dist) {\n      return intensity / (1.0 + dist * attenuation);\n    }\n    \n    float light2(float intensity, float attenuation, float dist) {\n      return intensity / (1.0 + dist * dist * attenuation);\n    }\n    \n    vec4 draw(vec2 uv) {\n      vec3 color1 = adjustHue(baseColor1, hue);\n      vec3 color2 = adjustHue(baseColor2, hue);\n      vec3 color3 = adjustHue(baseColor3, hue);\n      \n      float ang = atan(uv.y, uv.x);\n      float len = length(uv);\n      float invLen = len > 0.0 ? 1.0 / len : 0.0;\n      \n      float n0 = snoise3(vec3(uv * noiseScale, iTime * 0.5)) * 0.5 + 0.5;\n      float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\n      float d0 = distance(uv, (r0 * invLen) * uv);\n      float v0 = light1(1.0, 10.0, d0);\n      v0 *= smoothstep(r0 * 1.05, r0, len);\n      float cl = cos(ang + iTime * 2.0) * 0.5 + 0.5;\n      \n      float a = iTime * -1.0;\n      vec2 pos = vec2(cos(a), sin(a)) * r0;\n      float d = distance(uv, pos);\n      float v1 = light2(1.5, 5.0, d);\n      v1 *= light1(1.0, 50.0, d0);\n      \n      float v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\n      float v3 = smoothstep(innerRadius, mix(innerRadius, 1.0, 0.5), len);\n      \n      vec3 col = mix(color1, color2, cl);\n      col = mix(color3, col, v0);\n      col = (col + v1) * v2 * v3;\n      col = clamp(col, 0.0, 1.0);\n      \n      return extractAlpha(col);\n    }\n    \n    vec4 mainImage(vec2 fragCoord) {\n      vec2 center = iResolution.xy * 0.5;\n      float size = min(iResolution.x, iResolution.y);\n      vec2 uv = (fragCoord - center) / size * 2.0;\n      \n      float angle = rot;\n      float s = sin(angle);\n      float c = cos(angle);\n      uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n      \n      uv.x += hover * hoverIntensity * 0.1 * sin(uv.y * 10.0 + iTime);\n      uv.y += hover * hoverIntensity * 0.1 * sin(uv.x * 10.0 + iTime);\n      \n      return draw(uv);\n    }\n    \n    void main() {\n      vec2 fragCoord = vUv * iResolution.xy;\n      vec4 col = mainImage(fragCoord);\n      gl_FragColor = vec4(col.rgb * col.a, col.a);\n    }\n  `;\n</script>\n\n<Canvas\n\tbind:ogl\n\tonMouseMove={handleMouseMove}\n\tonMouseLeave={() => (targetHover = 0)}\n\tclass={className}\n\talpha={true}\n\tpremultipliedAlpha={false}\n\tonMount={({ gl }) => {\n\t\tgl?.clearColor(0, 0, 0, 0);\n\t}}\n>\n\t<Program\n\t\t{vertex}\n\t\t{fragment}\n\t\tuniforms={{\n\t\t\tiTime: { value: 0 },\n\t\t\tiResolution: { value: [1, 1, 1], noUpdate: true },\n\t\t\thue: { value: hue },\n\t\t\thover: { value: 0 },\n\t\t\trot: { value: 0 },\n\t\t\thoverIntensity: { value: hoverIntensity }\n\t\t}}\n\t\tonResize={({ width, height }, program) => {\n\t\t\tconst dpr = typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;\n\t\t\tprogram.program.uniforms.iResolution.value = [\n\t\t\t\twidth * dpr,\n\t\t\t\theight * dpr,\n\t\t\t\t(width * dpr) / (height * dpr)\n\t\t\t];\n\t\t}}\n\t\tonUpdate={({ time }, { program }) => {\n\t\t\tconst dt = (time - lastTime) * 0.001;\n\t\t\tlastTime = time;\n\n\t\t\t// Update uniforms with current prop values for reactivity\n\t\t\tprogram.uniforms.iTime.value = time * 0.001;\n\n\t\t\t// Smooth hover transition like original\n\t\t\tconst effectiveHover = forceHoverState ? 1 : targetHover;\n\t\t\tcurrentHover += (effectiveHover - currentHover) * 0.1;\n\t\t\tprogram.uniforms.hover.value = currentHover;\n\n\t\t\t// Rotation on hover like original\n\t\t\tif (rotateOnHover && effectiveHover > 0.5) {\n\t\t\t\tcurrentRot += dt * rotationSpeed;\n\t\t\t}\n\t\t\tprogram.uniforms.rot.value = currentRot;\n\t\t}}\n\t>\n\t\t<Triangle>\n\t\t\t<Mesh\n\t\t\t\tonUpdate={({ time }, mesh) => {\n\t\t\t\t\tmesh.ogl.renderer?.render({ scene: mesh.mesh });\n\t\t\t\t}}\n\t\t\t/>\n\t\t</Triangle>\n\t</Program>\n</Canvas>\n",
      "type": "registry:component"
    }
  ]
}