{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "particles",
  "type": "registry:block",
  "title": "Particles",
  "description": "Particles background component",
  "dependencies": [
    "svogl"
  ],
  "files": [
    {
      "path": "src/lib/backgrounds/Particles/Particles.svelte",
      "content": "<script lang=\"ts\">\n\timport { Canvas, OglContext, Program, Mesh, Camera, Geometry } from 'svogl';\n\tinterface ParticlesProps {\n\t\tparticleCount?: number;\n\t\tparticleSpread?: number;\n\t\tspeed?: number;\n\t\tparticleColors?: string[];\n\t\tmoveParticlesOnHover?: boolean;\n\t\tparticleHoverFactor?: number;\n\t\talphaParticles?: boolean;\n\t\tparticleBaseSize?: number;\n\t\tsizeRandomness?: number;\n\t\tcameraDistance?: number;\n\t\tdisableRotation?: boolean;\n\t\tclassName?: string;\n\t}\n\n\tlet {\n\t\tparticleCount = 200,\n\t\tparticleSpread = 10,\n\t\tspeed = 0.1,\n\t\tparticleColors = ['#ffffff', '#ffffff', '#ffffff'],\n\t\tmoveParticlesOnHover = true,\n\t\tparticleHoverFactor = 1,\n\t\talphaParticles = false,\n\t\tparticleBaseSize = 100,\n\t\tsizeRandomness = 1,\n\t\tcameraDistance = 20,\n\t\tdisableRotation = false,\n\t\tclassName = ''\n\t}: ParticlesProps = $props();\n\n\t// Constants\n\tconst defaultColors: string[] = ['#ffffff', '#ffffff', '#ffffff'];\n\n\t// Derived values\n\tconst palette = $derived(\n\t\tparticleColors && particleColors.length > 0 ? particleColors : defaultColors\n\t);\n\n\t// Shader code\n\tconst vertexShader = /* glsl */ `\n\t\tattribute vec3 position;\n\t\tattribute vec4 random;\n\t\tattribute vec3 color;\n\t\t\n\t\tuniform mat4 modelMatrix;\n\t\tuniform mat4 viewMatrix;\n\t\tuniform mat4 projectionMatrix;\n\t\tuniform float uTime;\n\t\tuniform float uSpread;\n\t\tuniform float uBaseSize;\n\t\tuniform float uSizeRandomness;\n\t\t\n\t\tvarying vec4 vRandom;\n\t\tvarying vec3 vColor;\n\t\t\n\t\tvoid main() {\n\t\t\tvRandom = random;\n\t\t\tvColor = color;\n\t\t\t\n\t\t\tvec3 pos = position * uSpread;\n\t\t\tpos.z *= 10.0;\n\t\t\t\n\t\t\tvec4 mPos = modelMatrix * vec4(pos, 1.0);\n\t\t\tfloat t = uTime;\n\t\t\tmPos.x += sin(t * random.z + 6.28 * random.w) * mix(0.1, 1.5, random.x);\n\t\t\tmPos.y += sin(t * random.y + 6.28 * random.x) * mix(0.1, 1.5, random.w);\n\t\t\tmPos.z += sin(t * random.w + 6.28 * random.y) * mix(0.1, 1.5, random.z);\n\t\t\t\n\t\t\tvec4 mvPos = viewMatrix * mPos;\n\t\t\tgl_PointSize = (uBaseSize * (1.0 + uSizeRandomness * (random.x - 0.5))) / length(mvPos.xyz);\n\t\t\tgl_Position = projectionMatrix * mvPos;\n\t\t}\n\t`;\n\n\tconst fragmentShader = /* glsl */ `\n\t\tprecision highp float;\n\t\t\n\t\tuniform float uTime;\n\t\tuniform float uAlphaParticles;\n\t\tvarying vec4 vRandom;\n\t\tvarying vec3 vColor;\n\t\t\n\t\tvoid main() {\n\t\t\tvec2 uv = gl_PointCoord.xy;\n\t\t\tfloat d = length(uv - vec2(0.5));\n\t\t\t\n\t\t\tif(uAlphaParticles < 0.5) {\n\t\t\t\tif(d > 0.5) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t\tgl_FragColor = vec4(vColor + 0.2 * sin(uv.yxx + uTime + vRandom.y * 6.28), 1.0);\n\t\t\t} else {\n\t\t\t\tfloat circle = smoothstep(0.5, 0.4, d) * 0.8;\n\t\t\t\tgl_FragColor = vec4(vColor + 0.2 * sin(uv.yxx + uTime + vRandom.y * 6.28), circle);\n\t\t\t}\n\t\t}\n\t`;\n\n\tlet lastTime = performance.now();\n\tlet elapsed = 0;\n\n\tlet ogl: OglContext | null = null;\n\n\tconst particleData = $derived.by(() => {\n\t\tconst count = particleCount;\n\t\tconst positions = new Float32Array(count * 3);\n\t\tconst randoms = new Float32Array(count * 4);\n\t\tconst colors = new Float32Array(count * 3);\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tlet x: number, y: number, z: number, len: number;\n\t\t\tdo {\n\t\t\t\tx = Math.random() * 2 - 1;\n\t\t\t\ty = Math.random() * 2 - 1;\n\t\t\t\tz = Math.random() * 2 - 1;\n\t\t\t\tlen = x * x + y * y + z * z;\n\t\t\t} while (len > 1 || len === 0);\n\t\t\tconst r = Math.cbrt(Math.random());\n\t\t\tpositions.set([x * r, y * r, z * r], i * 3);\n\t\t\trandoms.set([Math.random(), Math.random(), Math.random(), Math.random()], i * 4);\n\t\t\tconst col = ogl?.color.hexToArray(palette[Math.floor(Math.random() * palette.length)])!;\n\t\t\tcol && colors.set(col, i * 3);\n\t\t}\n\n\t\tconsole.log({ positions, randoms, colors });\n\t\treturn { positions, randoms, colors };\n\t});\n</script>\n\n<Canvas\n\tbind:ogl\n\tdepth={false}\n\talpha={true}\n\tonUpdate={({ time }) => {\n\t\tconst delta = time - lastTime;\n\t\tlastTime = time;\n\t\telapsed += delta * speed;\n\t}}\n\tclass={className}\n>\n\t{#snippet children(ogl)}\n\t\t<Program\n\t\t\tvertex={vertexShader}\n\t\t\tfragment={fragmentShader}\n\t\t\tonUpdate={({ time }, { program }) => {\n\t\t\t\tprogram.uniforms.uTime.value = elapsed * 0.001;\n\t\t\t}}\n\t\t\ttransparent={true}\n\t\t\tdepthTest={false}\n\t\t\tuniforms={{\n\t\t\t\tuTime: { value: 0 },\n\t\t\t\tuSpread: { value: particleSpread },\n\t\t\t\tuBaseSize: { value: particleBaseSize },\n\t\t\t\tuSizeRandomness: { value: sizeRandomness },\n\t\t\t\tuAlphaParticles: { value: alphaParticles ? 1 : 0 }\n\t\t\t}}\n\t\t>\n\t\t\t<Camera\n\t\t\t\tfov={15}\n\t\t\t\tleft={0}\n\t\t\t\ttop={0}\n\t\t\t\tzoom={cameraDistance}\n\t\t\t\tonUpdate={({ time }, { camera }) => {\n\t\t\t\t\tcamera.position.z = cameraDistance;\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t{#snippet children({ camera })}\n\t\t\t\t\t<Geometry\n\t\t\t\t\t\tattributes={{\n\t\t\t\t\t\t\tposition: { size: 3, data: particleData.positions },\n\t\t\t\t\t\t\trandom: { size: 4, data: particleData.randoms },\n\t\t\t\t\t\t\tcolor: { size: 3, data: particleData.colors }\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t<Mesh\n\t\t\t\t\t\t\tmode={ogl.gl.POINTS}\n\t\t\t\t\t\t\tonUpdate={({ time }, { mesh }) => {\n\t\t\t\t\t\t\t\tif (moveParticlesOnHover) {\n\t\t\t\t\t\t\t\t\tconst [x, y] = ogl.mousePosition;\n\t\t\t\t\t\t\t\t\tmesh.position.x = -x * particleHoverFactor;\n\t\t\t\t\t\t\t\t\tmesh.position.y = -y * particleHoverFactor;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmesh.position.x = 0;\n\t\t\t\t\t\t\t\t\tmesh.position.y = 0;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (!disableRotation) {\n\t\t\t\t\t\t\t\t\tmesh.rotation.x = Math.sin(elapsed * 0.0002) * 0.1;\n\t\t\t\t\t\t\t\t\tmesh.rotation.y = Math.cos(elapsed * 0.0005) * 0.15;\n\t\t\t\t\t\t\t\t\tmesh.rotation.z += 0.01 * speed;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\togl.renderer.render({ scene: mesh, camera });\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</Geometry>\n\t\t\t\t{/snippet}\n\t\t\t</Camera>\n\t\t</Program>\n\t{/snippet}\n</Canvas>\n",
      "type": "registry:component"
    }
  ]
}